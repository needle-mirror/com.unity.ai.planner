using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Unity.AI.Planner;
using Unity.AI.Planner.Utility;
using UnityEditor.AI.Planner.Utility;
using UnityEngine;
using UnityEngine.AI.Planner.DomainLanguage.TraitBased;

namespace UnityEditor.AI.Planner.CodeGen
{
    class CodeGenerator
    {
        CodeRenderer m_CodeRenderer = new CodeRenderer();
        List<string> m_GeneratedFilePaths = new List<string>();

        internal List<string> GenerateDomain(string outputPath, string rootFolder = null)
        {
            m_GeneratedFilePaths.Clear();
            DomainAssetDatabase.Refresh();

            bool anyEnums = false;
            foreach (var e in DomainAssetDatabase.EnumDefinitions)
            {
                if (rootFolder == null || !AssetDatabase.GetAssetPath(e).StartsWith(rootFolder))
                    continue;

                GenerateEnum(e, TypeResolver.DomainsNamespace, outputPath);
                anyEnums = true;
            }

            foreach (var trait in DomainAssetDatabase.TraitDefinitions)
            {
                if (rootFolder == null || !AssetDatabase.GetAssetPath(trait).StartsWith(rootFolder))
                    continue;

                GenerateTrait(trait, TypeResolver.DomainsNamespace, outputPath, anyEnums);
            }

            GeneratePlanningDomain(TypeResolver.DomainsNamespace, outputPath);

            var domainsNamespace = TypeResolver.DomainsNamespace;
            GenerateConditionalAssembly(domainsNamespace, "PLANNER_DOMAIN_GENERATED", outputPath);
            SaveToFile($"{outputPath}/{domainsNamespace}/AssemblyInfo.cs", "using System.Runtime.CompilerServices; [assembly: InternalsVisibleTo(\"AI.Planner.Actions\")]");

            return m_GeneratedFilePaths;
        }

        internal List<string> GeneratePlans(string outputPath, string rootFolder = null)
        {
            m_GeneratedFilePaths.Clear();
            DomainAssetDatabase.Refresh();

            var actionsNamespace = TypeResolver.ActionsNamespace;

            var anyEnums = DomainAssetDatabase.EnumDefinitions.Any();
            foreach (var plan in DomainAssetDatabase.PlanDefinitions)
            {
                if (rootFolder == null || !AssetDatabase.GetAssetPath(plan).StartsWith(rootFolder))
                    continue;

                foreach (var action in plan.ActionDefinitions)
                {
                    if (action != null)
                        GenerateAction(action, plan.Name, TypeResolver.DomainsNamespace, actionsNamespace, outputPath, anyEnums);
                }

                GenerateActionScheduler(plan, plan.Name, TypeResolver.ActionsNamespace, outputPath);

                GeneratePlanner(plan, plan.Name, TypeResolver.ActionsNamespace, outputPath, anyEnums);
            }
            GenerateConditionalAssembly(actionsNamespace, "PLANNER_ACTIONS_GENERATED", outputPath);

            return m_GeneratedFilePaths;
        }

        void GenerateTrait(TraitDefinition trait, string domainNamespace, string outputPath, bool includeEnums = false)
        {
            var fields = trait.Fields.Select(p => new
            {
                field_type = p.Type,
                field_name = p.Name
            });

            var result = m_CodeRenderer.RenderTemplate(PlannerResources.instance.TemplateTrait, new
            {
                @namespace = domainNamespace,
                name = trait.Name,
                fields = fields,
                include_enums = includeEnums,
            });

            SaveToFile($"{outputPath}/{domainNamespace}/Traits/{trait.Name}.cs", result);
        }

        void GenerateEnum(EnumDefinition @enum, string domainNamespace, string outputPath)
        {
            var result = m_CodeRenderer.RenderTemplate(PlannerResources.instance.TemplateEnum, new
            {
                Namespace = domainNamespace,
                Name = @enum.Name,
                Values = @enum.Values
            });

            SaveToFile($"{outputPath}/{domainNamespace}/Traits/{@enum.Name}.cs", result);
        }

        void GeneratePlanningDomain(string domainNamespace, string outputPath)
        {
            var traits = DomainAssetDatabase.TraitDefinitions.Select(p => new
            {
                name = p.Name,
                relations = p.Fields.Where(f => f.Type.EndsWith("ObjectId")).Select(f => new { name = f.Name })
            });

            foreach (var termination in DomainAssetDatabase.StateTerminationDefinitions)
            {
                GenerateTermination(termination, TypeResolver.DomainsNamespace, outputPath);
            }

            var result = m_CodeRenderer.RenderTemplate(PlannerResources.instance.TemplateDomain, new
            {
                domain_namespace = domainNamespace,
                trait_list = traits,
                num_traits = traits.Count()
            });

            SaveToFile($"{outputPath}/{domainNamespace}/PlanningDomainData.cs", result);
        }

        void GenerateTermination(StateTerminationDefinition termination, string domainNamespace, string outputPath)
        {
            var terminationName = termination.Name;

            var parameters = termination.Parameters.Select(p => new
            {
                Name = p.Name,
                required_traits = p.RequiredTraits,
                prohibited_traits = p.ProhibitedTraits,
            });

            var terminationCriteria = termination.Criteria;
            var criteriaTraits = terminationCriteria.Where(c => c.OperandA.Trait != null).Select(c => c.OperandA.Trait.Name)
                .Concat(terminationCriteria.Where(c => c.OperandB.Trait != null).Select(c => c.OperandB.Trait.Name))
                .Distinct();

            var parameterNames = parameters.Select(p => p.Name).ToList();
            var criteria = termination.Criteria.Select(p => new
            {
                @operator = p.Operator,
                operand_a = GetPreconditionOperandString(p.OperandA, parameterNames),
                operand_b = GetPreconditionOperandString(p.OperandB, parameterNames),
                loop_index = Mathf.Max(parameterNames.FindIndex(name => name == p.OperandA.Parameter)
                    , parameterNames.FindIndex(name => name == p.OperandB.Parameter))
            });

            var customRewards = termination.CustomRewards.Select(c => new
            {
                @operator = c.Operator,
                typename = TypeResolver.GetType(c.Typename).FullName,
                parameters = c.Parameters.Select((p, index) => new
                {
                    index = parameterNames.IndexOf(p),
                    type = TypeResolver.GetType(c.Typename).GetMethod("RewardModifier")?.GetParameters()[index].ParameterType
                })
            });

            var result = m_CodeRenderer.RenderTemplate(PlannerResources.instance.TemplateTermination, new
            {
                @namespace = domainNamespace,
                name = terminationName,
                parameter_list = parameters,
                criteria_traits = criteriaTraits.ToArray(),
                criteria_list = criteria.ToArray(),
                reward_value = termination.TerminalReward,
                custom_rewards =  customRewards,
            });
            SaveToFile($"{outputPath}/{domainNamespace}/{terminationName}.cs", result);
        }

        void GenerateActionScheduler(PlanDefinition definition, string planningNamespace, string domainNamespace, string outputPath)
        {
            int maxArgs = 0;
            foreach (var action in definition.ActionDefinitions)
            {
                if (action != null)
                    maxArgs = Math.Max(maxArgs, action.Parameters.Count());
            }

            var result = m_CodeRenderer.RenderTemplate(PlannerResources.instance.TemplateActionScheduler, new
            {
                planning_name = definition.Name,
                domain_namespace = $"{domainNamespace}.{planningNamespace}",
                actions = definition.ActionDefinitions,
                num_actions = definition.ActionDefinitions.Count(),
                num_args = maxArgs,
            });

            SaveToFile($"{outputPath}/{domainNamespace}/{planningNamespace}/ActionScheduler.cs", result);
        }

        void GeneratePlanner(PlanDefinition definition, string planningNamespace, string domainNamespace, string outputPath, bool includeEnums = false)
        {
            var heuristicTypeName = "DefaultHeuristic";
            if (!string.IsNullOrEmpty(definition.CustomHeuristic))
            {
                List<Type> heuristicTypes = new List<Type>();
                typeof(ICustomHeuristic<>).GetImplementationsOfInterface(heuristicTypes);

                var type = heuristicTypes.FirstOrDefault(h => h.Name == definition.CustomHeuristic);
                if (type != null)
                    heuristicTypeName = type.FullName;
            }

            var defaultHeuristic = new
            {
                lower = definition.DefaultHeuristicLower,
                avg = definition.DefaultHeuristicAverage,
                upper = definition.DefaultHeuristicUpper,
            };

            var result = m_CodeRenderer.RenderTemplate(PlannerResources.instance.TemplatePlanExecutor, new
            {
                plan_name = definition.Name,
                class_namespace = $"{domainNamespace}.{planningNamespace}",
                actions = definition.ActionDefinitions,
                traits = definition.GetTraitsUsed(),
                heuristic = heuristicTypeName,
                default_heuristic = defaultHeuristic,
                terminations = definition.StateTerminationDefinitions.Where(t => t != null).Select(t => t.name),
                include_enums = includeEnums,
            });

            SaveToFile($"{outputPath}/{domainNamespace}/{planningNamespace}/{definition.name}Executor.cs", result);
        }

        void GenerateAction(ActionDefinition action, string planName, string domainNamespace, string actionNamespace, string outputPath, bool includeEnums = false)
        {
            var parameters = action.Parameters.Select(p => new
            {
                Name = p.Name,
                required_traits = p.RequiredTraits,
                prohibited_traits = p.ProhibitedTraits,
            });

            var parameterNames = parameters.Select(p => p.Name).ToList();
            var traitPreconditionList = action.Preconditions.Where(p => !p.Operator.Contains('.'));
            var preconditions = traitPreconditionList.Select(p => new
            {
                Operator = p.Operator,
                operand_a = GetPreconditionOperandString(p.OperandA, parameterNames),
                operand_b = GetPreconditionOperandString(p.OperandB, parameterNames),
                loop_index = Mathf.Max(parameterNames.FindIndex(name => name == p.OperandA.Parameter)
                    , parameterNames.FindIndex(name => name == p.OperandB.Parameter))
            });

            var preconditionTraits = traitPreconditionList.Where(c => c.OperandA.Trait != null).Select(c => c.OperandA.Trait.Name)
                .Concat(traitPreconditionList.Where(c => c.OperandB.Trait != null).Select(c => c.OperandB.Trait.Name))
                .Distinct();

            var customPreconditionList = action.Preconditions.Where(p => p.Operator.Contains('.'));
            var customPreconditions = customPreconditionList.Select(p => p.Operator.Substring(p.Operator.IndexOf('.') + 1));

            var createdObjects = action.CreatedObjects.Select(c => new
            {
                name = c.Name,
                required_traits = c.RequiredTraits.Select(t => t.Name),
                prohibited_traits = c.ProhibitedTraits.Select(t => t.Name)
            });

            var requiredObjectBuffers = new HashSet<string>();
            var requiredTraitBuffers = new HashSet<string>();

            var objectModifiers = action.ObjectModifiers.Select(p => BuildModifierLines(action, p.Operator, p.OperandA, p.OperandB, ref requiredObjectBuffers, ref requiredTraitBuffers));

            var customRewards = action.CustomRewards.Select(c => new
            {
                @operator = c.Operator,
                typename = TypeResolver.GetType(c.Typename).FullName,
                parameters = c.Parameters.Select((p, index) => new
                {
                    index = parameterNames.IndexOf(p),
                    type = TypeResolver.GetType(c.Typename).GetMethod("RewardModifier")?.GetParameters()[index].ParameterType
                })
            });

            var result = m_CodeRenderer.RenderTemplate(PlannerResources.instance.TemplateAction, new
            {
                plan_name = planName,
                action_name = action.Name,
                action_namespace = actionNamespace,
                domain_namespace = domainNamespace,
                parameter_list = parameters.ToList(),
                precondition_list = preconditions.ToList(),
                precondition_traits = preconditionTraits.ToList(),
                created_objects = createdObjects.ToArray(),
                created_object_names = createdObjects.Select(c => c.name),
                object_modifiers = objectModifiers.ToList(),
                reward_value = action.Reward,
                custom_preconditions = customPreconditions,
                custom_rewards =  customRewards,
                include_enums = includeEnums,
                removed_objects = action.RemovedObjects,
                required_object_buffers = requiredObjectBuffers.ToList(),
                required_trait_buffers = requiredTraitBuffers.ToList(),
            });

            SaveToFile($"{outputPath}/{actionNamespace}/{planName}/{action.Name}.cs", result);
        }

        public string[] BuildModifierLines(ActionDefinition action, string @operator, OperandValue operandA, OperandValue operandB, ref HashSet<string> requiredObjectBuffers, ref HashSet<string> requiredTraitBuffers)
        {
            const string prefixNew = "new";
            const string prefixOriginal = "original";

            List<string> modifierLines = new List<string>();

            string operatorType = @operator.Split('.')[0];
            switch (operatorType)
            {
                case Operation.CustomOperator:
                {
                    var customClass = @operator.Split('.')[1];

                    modifierLines.Add($"new {customClass}().ApplyCustomActionEffectsToState(originalState, action, newState);");
                }
                    break;
                case Operation.AddTraitOperator:
                {
                    if ((string.IsNullOrEmpty(operandA.Parameter) || operandB.Trait == null))
                    {
                        throw new ArgumentException("Invalid operands for an Add trait operator");
                    }
                    var parameter = operandA.Parameter;
                    var trait = operandB.Trait.Name;

                    requiredObjectBuffers.Add(parameter);

                    modifierLines.Add($"newState.SetTraitOnObject<{trait}>(default({trait}), ref original{parameter}Object);");
                }
                    break;
                case Operation.RemoveTraitOperator:
                {
                    if ((string.IsNullOrEmpty(operandA.Parameter) || operandB.Trait == null))
                    {
                        throw new ArgumentException("Invalid operands for a Remove trait operator");
                    }
                    var parameter = operandA.Parameter;
                    var trait = operandB.Trait.Name;

                    requiredObjectBuffers.Add(parameter);

                    modifierLines.Add($"newState.RemoveTraitOnObject<{trait}>(ref original{parameter}Object);");
                }
                    break;
                default:
                {
                    if (string.IsNullOrEmpty(operandA.Parameter) || operandA.Trait == null)
                    {
                        throw new ArgumentException("Invalid operands for a trait modifier");
                    }

                    var parameterNames = action.Parameters.Select(p => p.Name).ToList();

                    var paramA = operandA.Parameter;
                    var traitA = operandA.Trait.Name;
                    var fieldA = operandA.TraitFieldName;

                    requiredTraitBuffers.Add(traitA);

                    bool originalObject = parameterNames.Contains(paramA);
                    var objectAPrefix = originalObject ? prefixOriginal : prefixNew;

                    if (originalObject)
                    {
                        requiredObjectBuffers.Add(paramA);
                    }

                    modifierLines.Add($"var @{traitA} = new{traitA}Buffer[{objectAPrefix}{paramA}Object.{traitA}Index];");

                    if (operandB.Trait == null)
                    {
                        if (operandB.Enum != null)
                        {
                            modifierLines.Add($"@{traitA}.@{fieldA} {@operator} {operandB.Enum.Name}.{operandB.Value};");
                        }
                        else if (parameterNames.Contains(operandB.Parameter))
                        {
                            requiredObjectBuffers.Add(operandB.Parameter);
                            modifierLines.Add($"@{traitA}.@{fieldA} {@operator} originalState.GetTraitBasedObjectId(original{operandB.Parameter}Object);");
                        }
                        else if (action.CreatedObjects.Any(c => c.Name == operandB.Parameter))
                        {
                            modifierLines.Add($"@{traitA}.@{fieldA} {@operator} new{operandB.Parameter}ObjectId;");
                        }
                        else
                        {
                            modifierLines.Add($"@{traitA}.@{fieldA} {@operator} {operandB.Value};");
                        }
                    }
                    else
                    {
                        string traitB = operandB.Trait.Name;
                        string fieldB = operandB.TraitFieldName;

                        requiredTraitBuffers.Add(traitB);

                        var objectBPrefix = parameterNames.Contains(operandB.Parameter) ? prefixOriginal : prefixNew;
                        if (objectBPrefix == prefixOriginal)
                        {
                            requiredObjectBuffers.Add(operandB.Parameter);
                        }

                        modifierLines.Add($"@{traitA}.{fieldA} {@operator} new{traitB}Buffer[{objectBPrefix}{operandB.Parameter}Object.{traitB}Index].{fieldB};");
                    }

                    modifierLines.Add($"new{traitA}Buffer[{objectAPrefix}{paramA}Object.{traitA}Index] = @{traitA};");
                }
                    break;
            }

            return modifierLines.ToArray();
        }

        void GenerateConditionalAssembly(string domainNamespace, string define, string outputPath)
        {
            var result = m_CodeRenderer.RenderTemplate(PlannerResources.instance.TemplateConditionalAssembly, new
            {
                @namespace = domainNamespace,
                define = define
            });

            SaveToFile($"{outputPath}/{domainNamespace}/ConditionalAssembly.cs", result);
        }

        void SaveToFile(string filePath, string text)
        {
            Directory.CreateDirectory(Path.GetDirectoryName(filePath));

            File.WriteAllText(filePath, text);
            AssetDatabase.ImportAsset(filePath);

            m_GeneratedFilePaths.Add(filePath);
        }

        string GetPreconditionOperandString(OperandValue operand, List<string> parameterNames)
        {
            if (operand.Trait == null)
            {
                if (operand.Enum != null)
                {
                    return $"{operand.Enum.Name}.{operand.Value}";
                }
                else if (parameterNames.Contains(operand.Parameter))
                {
                    return $"stateData.GetTraitBasedObjectId({operand.Parameter}Index)";
                }

                return operand.Value;
            }

            var precondition =  $"{operand.Trait.Name}Buffer[{operand.Parameter}Object.{operand.Trait.Name}Index]";
            if (!string.IsNullOrEmpty(operand.TraitFieldName))
                precondition +=  $".{operand.TraitFieldName}";

            return precondition;
        }
    }
}
